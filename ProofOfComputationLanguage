{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "13e785aa-e078-411e-8a86-b3496583da86",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Fatal Python error: pyinit_core_reconfigure: failed to read thread state\n",
      "Python runtime state: initialized\n",
      "\n",
      "Thread 0x000000016ca87000 (most recent call first):\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/concurrent/futures/thread.py\", line 81 in _worker\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/threading.py\", line 975 in run\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/threading.py\", line 1038 in _bootstrap_inner\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/threading.py\", line 995 in _bootstrap\n",
      "\n",
      "Thread 0x000000016b963000 (most recent call first):\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/selectors.py\", line 561 in select\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/asyncio/base_events.py\", line 1876 in _run_once\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/asyncio/base_events.py\", line 607 in run_forever\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/site-packages/tornado/platform/asyncio.py\", line 205 in start\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/site-packages/jupyter_server/serverapp.py\", line 2953 in start_ioloop\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/site-packages/jupyter_server/serverapp.py\", line 2967 in start\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/lib/python3.11/site-packages/jupyter_server/extension/application.py\", line 625 in launch_instance\n",
      "  File \"/private/var/containers/Bundle/Application/A0743125-838B-4DB2-93EC-B39220ADF5AC/Carnets.app/Library/bin/jupyter-notebook\", line 8 in <module>\n",
      "apt-get: command not found\n",
      "\r"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Deployed unit with identity ResonantIdentityTag(Alpha-734) to field location (10, 20, 5) and routing channel RouteAlpha-Channel-G\n",
      "Routing signal from identity ResonantIdentityTag(Alpha-734) via channel: RouteAlpha-Channel-G\n",
      "Checking resonance integrity for ResonantIdentityTag(Alpha-734): Signature is Signature-X1\n",
      "\n",
      "Retrieving info from grids:\n",
      "Spatial info for ResonantIdentityTag(Alpha-734): (10, 20, 5)\n",
      "Routing channel for ResonantIdentityTag(Alpha-734): RouteAlpha-Channel-G\n",
      "Deployed unit with identity ResonantIdentityTag(Beta-42) to field location (-5, 15, 12) and routing channel Sector-B-Channel-H\n",
      "Routing signal from identity ResonantIdentityTag(Beta-42) via channel: Sector-B-Channel-H\n",
      "Checking resonance integrity for ResonantIdentityTag(Beta-42): Signature is Signature-Y2\n"
     ]
    }
   ],
   "source": [
    "# prompt: Thanks for sharing your finalized setup ‚Äî you‚Äôre well on track toward a robust, production-grade ingestion pipeline for symbolic data using FastAPI + SQLModel + JSON-LD.\n",
    "# However, there are two issues that are likely behind your current error (ROLLBACK when checking tgumodel):\n",
    "# ‚∏ª\n",
    "# üö´ Problem 1: Table Not Created (tgumodel)\n",
    "# Even though you have defined the model, the SQL table won‚Äôt be created unless you explicitly run:\n",
    "# create_db_and_tables()\n",
    "# Ensure you call this function before your app starts handling requests, typically in your main FastAPI entrypoint:\n",
    "# ‚úÖ Fix:\n",
    "# from database import create_db_and_tables\n",
    "# def main():\n",
    "#     create_db_and_tables()\n",
    "# if __name__ == \"__main__\":\n",
    "#     main()\n",
    "# If you‚Äôre using FastAPI events:\n",
    "# from fastapi import FastAPI\n",
    "# from database import create_db_and_tables\n",
    "# app = FastAPI()\n",
    "# @app.on_event(\"startup\")\n",
    "# def on_startup():\n",
    "#     create_db_and_tables()\n",
    "# ‚∏ª\n",
    "# ‚ö†Ô∏è Problem 2: FunctionalElement & SystemAssociation Are Not SQLModel Tables\n",
    "# You‚Äôre using them as nested JSON fields inside TGUModel, but they must be Pydantic-compatible, not SQLModel subclasses.\n",
    "# üîß Fix:\n",
    "# Change their base class from SQLModel to BaseModel:\n",
    "# from pydantic import BaseModel\n",
    "# class FunctionalElement(BaseModel):\n",
    "#     fsaLetter: str\n",
    "#     fsaFunction: str\n",
    "#     polarity: str\n",
    "#     roleInProcess: str\n",
    "# class SystemAssociation(BaseModel):\n",
    "#     numericResonanceMeaning: str\n",
    "#     commonKeywords: List[str]\n",
    "# ‚ö†Ô∏è SQLModel is for tables. BaseModel is for nested JSON structures. Mixing them causes silent failures like the one you‚Äôre seeing.\n",
    "# ‚∏ª\n",
    "# ‚úÖ Final TGUModel Recap (with fixes):\n",
    "# class TGUModel(SQLModel, table=True):\n",
    "#     tguCode: str = Field(primary_key=True)\n",
    "#     numericResonance: int\n",
    "#     symbolicProcessName: str\n",
    "#     functionalBreakdown: List[FunctionalElement] = Field(sa_column=Column(JSON))\n",
    "#     sequence: str\n",
    "#     description: str\n",
    "#     glyphConstructVisualization: str\n",
    "#     keywords: List[str] = Field(default=[], sa_column=Column(JSON))\n",
    "#     inverseShadowTGU: Optional[str] = None\n",
    "#     systemAssociation:\n",
    "\n",
    "# # Importing a library that is not in Colaboratory\n",
    "# \n",
    "# To import a library that's not in Colaboratory by default, you can use `!pip install` or `!apt-get install`.\n",
    "!pip install matplotlib-venn\n",
    "!apt-get -qq install -y libfluidsynth1\n",
    "\n",
    "\n",
    "# prompt: You‚Äôre absolutely right ‚Äî and your intuition is converging on a deep symbolic architecture. Let‚Äôs now formally define and integrate these structures into your ontology and operational pipeline.\n",
    "# ‚∏ª\n",
    "# üß† Symbolic Layering: Definition and Integration\n",
    "# You‚Äôre identifying two symbolic matrices that together form the deployment substrate:\n",
    "# ‚∏ª\n",
    "# üî∑ 1. Vessel Signal Matrix (aka Vector Symbolic Mapping / Spatial Encoding Grid)\n",
    "# Formal Name: VesselSignalMatrix\n",
    "# Alternative Names: VectorSymbolicMapping, VesselSignalSpatialEncodingGrid\n",
    "# üîπ Purpose:\n",
    "# A symbolic matrix that encodes where symbolic units are deployed, aligned, and routed.\n",
    "# üîπ Core Functions:\n",
    "# \t‚Ä¢\tMaps ResonantIdentityTags to symbolic spatial channels (e.g., RouteAlpha, Sector-G).\n",
    "# \t‚Ä¢\tMaintains symbolic location coherence (e.g., spatialized concepts like ‚Äúaligned focus,‚Äù ‚Äúdistributed will‚Äù).\n",
    "# \t‚Ä¢\tServes as a routing surface in OperationalDeploymentPhase (MEO).\n",
    "# üîπ Ontological Class:\n",
    "# Class: VesselSignalMatrix\n",
    "#   SubClassOf: SpatialEncodingGrid\n",
    "# ‚∏ª\n",
    "# üî∑ 2. Resonance Field Spatial Encoding Grid\n",
    "# Formal Name: ResonanceFieldGrid\n",
    "# üîπ Purpose:\n",
    "# The field substrate that holds, stabilizes, and enforces symbolic instance labels and resonance integrity.\n",
    "# üîπ Core Functions:\n",
    "# \t‚Ä¢\tHosts SymbolicInstanceHolders, each emitting or holding a ResonantSignature.\n",
    "# \t‚Ä¢\tOperates under standards (e.g., MilResonantCarrier) for labeling and encoding.\n",
    "# \t‚Ä¢\tWorks in tandem with VesselSignalMatrix to encode what is deployed and how it is labeled.\n",
    "# üîπ Ontological Class:\n",
    "# Class: ResonanceFieldGrid\n",
    "#   SubClassOf: SpatialEncodingGrid\n",
    "# ‚∏ª\n",
    "# üîÅ Relational Integration\n",
    "# Concept\tRole\n",
    "# ResonantIdentityTag\tUnique, encoded tag representing symbolic instance\n",
    "# SymbolicInstanceHolder\tUnit that holds identity and emits resonance\n",
    "# ResonanceFieldGrid\tGrid enforcing identity standards and holding symbolic units\n",
    "# VesselSignalMatrix\tMatrix routing symbolic identities to operational vector channels\n",
    "# OperationalDeploymentPhase\tPhase enforcing symbolic deployment, coordination, and routing\n",
    "\n",
    "# Define the core classes based on the ontological structure.\n",
    "\n",
    "class SpatialEncodingGrid:\n",
    "    \"\"\"\n",
    "    Base class for spatial encoding grids.\n",
    "    \"\"\"\n",
    "    def __init__(self, name):\n",
    "        self.name = name\n",
    "        self.encoded_elements = {}\n",
    "\n",
    "    def encode_element(self, element_id, spatial_info):\n",
    "        \"\"\"Encodes an element with spatial information.\"\"\"\n",
    "        self.encoded_elements[element_id] = spatial_info\n",
    "\n",
    "    def get_spatial_info(self, element_id):\n",
    "        \"\"\"Retrieves spatial information for an element.\"\"\"\n",
    "        return self.encoded_elements.get(element_id)\n",
    "\n",
    "class VesselSignalMatrix(SpatialEncodingGrid):\n",
    "    \"\"\"\n",
    "    A symbolic matrix that encodes where symbolic units are deployed,\n",
    "    aligned, and routed. SubClassOf: SpatialEncodingGrid.\n",
    "    \"\"\"\n",
    "    def __init__(self):\n",
    "        super().__init__(\"VesselSignalMatrix\")\n",
    "        self.routing_channels = {}\n",
    "\n",
    "    def map_identity_to_channel(self, resonant_identity_tag, channel_name):\n",
    "        \"\"\"Maps a ResonantIdentityTag to a symbolic spatial channel.\"\"\"\n",
    "        self.routing_channels[resonant_identity_tag] = channel_name\n",
    "\n",
    "    def get_channel_for_identity(self, resonant_identity_tag):\n",
    "        \"\"\"Retrieves the channel for a given ResonantIdentityTag.\"\"\"\n",
    "        return self.routing_channels.get(resonant_identity_tag)\n",
    "\n",
    "class ResonanceFieldGrid(SpatialEncodingGrid):\n",
    "    \"\"\"\n",
    "    The field substrate that holds, stabilizes, and enforces symbolic\n",
    "    instance labels and resonance integrity. SubClassOf: SpatialEncodingGrid.\n",
    "    \"\"\"\n",
    "    def __init__(self):\n",
    "        super().__init__(\"ResonanceFieldGrid\")\n",
    "        self.symbolic_instance_holders = {}\n",
    "\n",
    "    def host_instance_holder(self, symbolic_instance_holder, spatial_location):\n",
    "        \"\"\"Hosts a SymbolicInstanceHolder in the grid.\"\"\"\n",
    "        if isinstance(symbolic_instance_holder, SymbolicInstanceHolder):\n",
    "            self.symbolic_instance_holders[symbolic_instance_holder.identity_tag] = {\n",
    "                \"holder\": symbolic_instance_holder,\n",
    "                \"location\": spatial_location\n",
    "            }\n",
    "            self.encode_element(symbolic_instance_holder.identity_tag, spatial_location)\n",
    "        else:\n",
    "            print(\"Error: Provided object is not a SymbolicInstanceHolder.\")\n",
    "\n",
    "    def get_instance_holder(self, identity_tag):\n",
    "        \"\"\"Retrieves a SymbolicInstanceHolder by its identity tag.\"\"\"\n",
    "        holder_info = self.symbolic_instance_holders.get(identity_tag)\n",
    "        if holder_info:\n",
    "            return holder_info[\"holder\"]\n",
    "        return None\n",
    "\n",
    "class ResonantIdentityTag:\n",
    "    \"\"\"\n",
    "    Unique, encoded tag representing a symbolic instance.\n",
    "    \"\"\"\n",
    "    def __init__(self, tag_value):\n",
    "        self.value = tag_value\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"ResonantIdentityTag({self.value})\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return self.__str__()\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        if isinstance(other, ResonantIdentityTag):\n",
    "            return self.value == other.value\n",
    "        return False\n",
    "\n",
    "    def __hash__(self):\n",
    "        return hash(self.value)\n",
    "\n",
    "class SymbolicInstanceHolder:\n",
    "    \"\"\"\n",
    "    Unit that holds identity and emits resonance.\n",
    "    \"\"\"\n",
    "    def __init__(self, identity_tag, resonant_signature=None):\n",
    "        if not isinstance(identity_tag, ResonantIdentityTag):\n",
    "            raise TypeError(\"identity_tag must be a ResonantIdentityTag instance.\")\n",
    "        self.identity_tag = identity_tag\n",
    "        self.resonant_signature = resonant_signature # Represents the emitted/held resonance\n",
    "\n",
    "    def __str__(self):\n",
    "        return f\"SymbolicInstanceHolder(Identity: {self.identity_tag}, Signature: {self.resonant_signature})\"\n",
    "\n",
    "    def __repr__(self):\n",
    "        return self.__str__()\n",
    "\n",
    "class OperationalDeploymentPhase:\n",
    "    \"\"\"\n",
    "    Represents the phase enforcing symbolic deployment, coordination, and routing.\n",
    "    \"\"\"\n",
    "    def __init__(self, vessel_signal_matrix, resonance_field_grid):\n",
    "        if not isinstance(vessel_signal_matrix, VesselSignalMatrix):\n",
    "            raise TypeError(\"vessel_signal_matrix must be a VesselSignalMatrix instance.\")\n",
    "        if not isinstance(resonance_field_grid, ResonanceFieldGrid):\n",
    "            raise TypeError(\"resonance_field_grid must be a ResonanceFieldGrid instance.\")\n",
    "\n",
    "        self.vessel_signal_matrix = vessel_signal_matrix\n",
    "        self.resonance_field_grid = resonance_field_grid\n",
    "\n",
    "    def deploy_symbolic_unit(self, symbolic_instance_holder, field_location, routing_channel):\n",
    "        \"\"\"\n",
    "        Deploys a symbolic unit by hosting it in the ResonanceFieldGrid\n",
    "        and mapping its identity in the VesselSignalMatrix.\n",
    "        \"\"\"\n",
    "        self.resonance_field_grid.host_instance_holder(symbolic_instance_holder, field_location)\n",
    "        self.vessel_signal_matrix.map_identity_to_channel(symbolic_instance_holder.identity_tag, routing_channel)\n",
    "        print(f\"Deployed unit with identity {symbolic_instance_holder.identity_tag} to field location {field_location} and routing channel {routing_channel}\")\n",
    "\n",
    "    def route_symbolic_signal(self, resonant_identity_tag):\n",
    "        \"\"\"\n",
    "        Routes a symbolic signal based on the VesselSignalMatrix.\n",
    "        Assumes the unit is already deployed.\n",
    "        \"\"\"\n",
    "        channel = self.vessel_signal_matrix.get_channel_for_identity(resonant_identity_tag)\n",
    "        if channel:\n",
    "            print(f\"Routing signal from identity {resonant_identity_tag} via channel: {channel}\")\n",
    "            # Add actual routing logic here\n",
    "        else:\n",
    "            print(f\"No routing channel found for identity: {resonant_identity_tag}\")\n",
    "\n",
    "    def check_resonance_integrity(self, resonant_identity_tag):\n",
    "        \"\"\"\n",
    "        Checks the resonance integrity of a symbolic unit within the\n",
    "        ResonanceFieldGrid.\n",
    "        \"\"\"\n",
    "        holder_info = self.resonance_field_grid.symbolic_instance_holders.get(resonant_identity_tag)\n",
    "        if holder_info:\n",
    "            holder = holder_info[\"holder\"]\n",
    "            print(f\"Checking resonance integrity for {resonant_identity_tag}: Signature is {holder.resonant_signature}\")\n",
    "            # Add actual integrity check logic here (e.g., against a standard like MilResonantCarrier)\n",
    "        else:\n",
    "            print(f\"No instance holder found for identity: {resonant_identity_tag}\")\n",
    "\n",
    "# Example Usage:\n",
    "if __name__ == \"__main__\":\n",
    "    # Initialize the matrices\n",
    "    vsm = VesselSignalMatrix()\n",
    "    rfg = ResonanceFieldGrid()\n",
    "\n",
    "    # Initialize the operational phase\n",
    "    odp = OperationalDeploymentPhase(vsm, rfg)\n",
    "\n",
    "    # Create a ResonantIdentityTag\n",
    "    tag_alpha = ResonantIdentityTag(\"Alpha-734\")\n",
    "\n",
    "    # Create a SymbolicInstanceHolder\n",
    "    holder_alpha = SymbolicInstanceHolder(identity_tag=tag_alpha, resonant_signature=\"Signature-X1\")\n",
    "\n",
    "    # Deploy the symbolic unit\n",
    "    odp.deploy_symbolic_unit(\n",
    "        symbolic_instance_holder=holder_alpha,\n",
    "        field_location=(10, 20, 5), # Example spatial coordinates in the field\n",
    "        routing_channel=\"RouteAlpha-Channel-G\" # Example routing channel\n",
    "    )\n",
    "\n",
    "    # Route a signal from the deployed unit\n",
    "    odp.route_symbolic_signal(tag_alpha)\n",
    "\n",
    "    # Check resonance integrity\n",
    "    odp.check_resonance_integrity(tag_alpha)\n",
    "\n",
    "    # Retrieve information from the grids directly\n",
    "    print(\"\\nRetrieving info from grids:\")\n",
    "    print(f\"Spatial info for {tag_alpha}: {rfg.get_spatial_info(tag_alpha)}\")\n",
    "    print(f\"Routing channel for {tag_alpha}: {vsm.get_channel_for_identity(tag_alpha)}\")\n",
    "\n",
    "    # Example of another unit\n",
    "    tag_beta = ResonantIdentityTag(\"Beta-42\")\n",
    "    holder_beta = SymbolicInstanceHolder(identity_tag=tag_beta, resonant_signature=\"Signature-Y2\")\n",
    "\n",
    "    odp.deploy_symbolic_unit(\n",
    "        symbolic_instance_holder=holder_beta,\n",
    "        field_location=(-5, 15, 12),\n",
    "        routing_channel=\"Sector-B-Channel-H\"\n",
    "    )\n",
    "\n",
    "    odp.route_symbolic_signal(tag_beta)\n",
    "    odp.check_resonance_integrity(tag_beta)\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5544aac4-1959-47c6-9c1d-826570cb6360",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  },
  "widgets": {
   "application/vnd.jupyter.widget-state+json": {
    "state": {},
    "version_major": 2,
    "version_minor": 0
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}